# 贪吃蛇的文档
## 沈瑜石 518021911058

1. 游戏的首页是一个gamemenu，上面有不同按钮，对应不同模式。newgame是最普通的单人游戏，multipleplayer是双人游戏，aisnake是一个ai蛇自己走，aiAndHuman是人机对战。scoreBoard是看单人游戏的最高分。set是设置游戏的地图大小，格子大小，食物和障碍物数量。
2. game类是整个游戏的控制类，判定游戏下一步干什么。game的构造函数中，先进行初始化。主要有snake，food，obstacle等子类。这些子类都是以数组的形式保存在game中。connect子类的信号函数和game的槽函数，画出界面。然后开启计时器。每当计时器时间到了时，调用自己定义的update函数。通过重载keypressbutton控制蛇的方向。整个ai蛇的函数也在这个类里面。
3. snake类是蛇。蛇通过单循环链表实现。通过公有函数act，game类可以在update中让snake走到下一个状态。act接受game传过来的地图map指针，调用nextstep，eat，grow，move等私有函数使蛇的状态改变，并改变map，发出信号。
4. food类是食物。在game初始化时随机生成食物。当snake发出信号表示食物被吃时，析构原来的snake，重新随机一个在蛇身体外的食物，然后改变传入的map。food有三种特殊种类，由game判断，并分别给出特效及作用时间。
5. obstacle是障碍物，game初始化时生成并在map中标记。在地图大小足够小的时候，加入一个用深度优先判断是否存在哈密顿路的算法，会在标题栏提示一下，但这不会改变什么。
6. ai蛇在gameai.cpp中。在每次update之后调用aisnake函数来改变蛇的方向。当有新事物时，创建一个test蛇模拟，寻找蛇头到食物的最短路径，用a\*算法寻找。如果能找得到食物，找到后只取第一步让test蛇在一个模拟的地图mapT上行动一步，然后同样去找下一步。test蛇走到食物后检查有没有到达蛇尾巴的路径，如果有则把上述路径记录下来，以后调用。如果没有就用a\*算法找头到尾巴最远路径的第一步并走，下次仍然判断能不能找到食物，或者吃到后能不能找到蛇尾。在人机对战中，aisnake函数进行了改进。蛇每次用test蛇测试能否到达食物，以及能否在吃到后找到尾巴。如果能的话只走第一步，否则去找尾巴。如果尾巴找不到，就随便走了。这个aisnake只能适应同时出现一个果子的局面。所有的特效果实不会影响ai蛇。
7. 游戏死亡后会有死亡界面，统计分数。胜利后有胜利界面。
8. 细节：在多人对战或人机对战时，如果两个蛇头对撞，判定分数高的赢，分数一样snake0死。两个蛇也可以进入对方尾部刚刚离开的格子。为了防止短时间内快速按两下导致的可能转身自杀，管理一个bool值active使一次update只能按一下有效按键来改变方向。双人及人机对战时因为加快速度会影响两蛇计时器的同步性，速度不会随分数的增加而增加。可以在set里开两蛇互吃模式。
